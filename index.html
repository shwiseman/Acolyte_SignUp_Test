<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Acolyte Sign-Up Form</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Acolyte Sign-Up Form</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="CONTINUE" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e0ad9379062bfbb1a889892268e54e289d45cf71b9ac7bc86efd4ed8453cf30c001d95d4d83106c317eb58aab929938b3efdfbfb566ee0652fcb8befb0d90decaaccfd0113124c961033acf8646991a6c17c23d7e23c78780f14775fd07166d5f756b5f76553900d11a9e9bfc82feed5a140b1d390c374d3b0c9562047c8369fedd1220ca7c2f4db0bf6e7a36d84b82d56f2364d716b57c79e3b580555da25a79eddf276c86b07d228e5f784514a71e22a66e8be234684d4ef8429d5129de0145d0572c82caffe4b08f14a98fcad95dd3867b907ed37a22137a67225a3edc78b949f5ef3caec0edef629b39de07700fdd35a34c8e1f27c79badc65d0450378d68f9a6387d47cf0c31439f7181f1d02742da7fb0d56d713305bd44740032787bc24e4a37687ff1ead7c1dd3285233980f8eded57a854c2939c60653e19004276e8119efa6ef83c2e37bf7e891d0d862d3310af326d9b9b2de522c73e8ae114ae511553a5a9dd6f246918ad9c5f251e09ef87982292620186fe1962e55d912303f878e00b800fb855434f154d397007cb0ae3d78c48af2354cff320c60dd2572f0ac0e1204049dada351d839caf5f374beb0ed356e32e81cb104e90ba8af979b1c3b425a6b0533db074469ce3c8ae00efae0f6c4dd1854e79a11ded88c3fb769ea7d919c40a58631f6db64b2c38aa1691ad45e709c9f08c3d9a1e3af9da6bf7807e97996fa1d4653b9771b08b37f9f54c9ee41830458738d70befb683cc0906afe1d868032a8d0e209e6c6904ea82b2c07de7d5058664dbb54ae91b73c3c219b9ea2956f4bffc24a106c7336a194c2d02f97faa646dd98db43561f7efcf36e6d66d2ba9160f13ca3016d957c51fdd466197477649fb34367b46bf707b21a9464dd8603beb2158ec67209e2f5c27c1a965cf281e2d36515ea7207086845d82fad6db2744018936322deb39e3be8cb1f7bfd96501951e031ca93c97f8f88a9b0b6ce464d13acf3ffacb16a49316df8dd4b5bb3b159fe3a8c364d64fd96f38cf3077c4fec5f2eeaa40c2130330ab5d1ec4e5150357523feaa28ddc0d20c5a1948794556407e1e0a4df0c05d9788e276414710fb69515ea9da329ca258c2ed81c1a62409963e8637835860eeadd0fd445e8b438c01a37fec67991ac5a49dd19015b632fcd1c5db386c169268a69f0754db387fa69e76230d31095d20aa7429d034e2db70cf8a4f78a18dee8b5061567ce5dc9f7920d6ea7e4073c8b24742fdcc9e1eec177d98f987617f9c19c24326d76f738898431abbabcb3cabad6fbd0dcd8a5c37b11bfbe6a3de09a6543ee02fd527b5fbed5c638ab3effa1819a23e03d1249c4903208e1169f0438dab971ee84acbbe9e1457c54a9b44ae3e8c509adc2102652bd905f1c4a82e9b4567380c39d7111db3cf19568edd506d38e1fc042457b0e238173a2a296c85115841bb58ac7a8bb652b0752663f8bdc1013843f675077b54bf13680ee8269fe8eb349c63519ade0e4f295baf55dcd12d1429c9b33d06b3e02ba54af0e3cead3ade8c4841db162ecfdb8aec08d8f6d21f43c60969637a9e15a2e7e06cfa82b4763c6f146aa57b74d794e23077ef324c28919ad94217c7933f7465c3f9d7039196e9e9e612265edb7ce8b2ae2d197306a16973880120d833c1023b713d436838b88bdb408c5c21c4c4e30c628de3d990d20e1d552b52eb8fcb78d3b24debb969c7a3b56a3b9724b958e38dc4d787f91a5d8ecb554dad77665f9d13f8703db1812665c163a58658b9960d8da59312fb92b38b756532bab9495d30578c294a43c950fe2f1c384524f15fcc17e449a73b031cb960678d3edb2e461ec18d8c7a79e729d9b8bde694506eca7f277e856cf2e7f0df5e6e89cab470ab018406747c73096e51575355f0a0960fae20a081b2f06c82e630bfdc7fca28f6bb5ff62f0267c565d2ff85d5f78dd30985a2b684282d8a642ff282a49a669c4db16fad8efe689f5da30bcc1035240876edb47c953e36cdfdb7e3517db5afa3208593b60d11ad7dffc8083489b4809573a9a01e28c87f7444c2d5dc445152504e184566c334984618fe676071bc55245ba38dfbd75eedc7d3779dc8d39003fc003845293979685884111477f3a7405b213122fcc516456fba4692254dd244f877bbca26eecfe50032315d1b9f2796e3ce871f6921e5ab827caec9efe53e946deab0c41c3130cc3dfb08a04da490f3091f737ce96fe441a4cd716bdfdd3c80c6816c74a3f49cacc00291ad9c371133257c7153bbe17808e835abd8d6234162ed1d7e1388831630e165dd41d440e5ca326cefe8524c521eba0b109b5c6cb2cbdf8221293e5ddb37084c6ef41dd92ffefeb9a0e7c95fcb58b75d86d6f3ce8e463335269973248a498d140bff599d81351ae8d499d9d217eccffa572237b165089c92251c668f20ebab30dd442521cedf443e9e6df1504c78f95d5721cf12a5971de646faf5b5480900e0afff28072eba61456513eb814fc591a0cae580b540bbf4d1f6d5d185acd63af46134b3762b38b7e9f3094bc87b20b9be0e96a45bb9062f92c9b21f96c615d47c774cecceae602b595d5519198d9444da1e98621ad8295c05b4043382106fcb8207946a3cbae0752b9b2b5ad40dda141e51449b89aa6aac0ecb1dfa6f36171e2f03e743d3c9285bde1e81ff1cfa1a56675cbac75679f3548a146b4ad3130900580cfa84dfe65a5a5b9990afdfa5f738986fdf7b65e27c7e13e4823109783a4f4d4aca50327906125d4121d339253dec248e09ec1cc6724a83afdb5728c38474aa29f8218e6f97891f5437a70028049649a2294224199bbfd5f76e144df9559a7865b06fa652eb6c0648395de3cf8468402c61c397ca74ef4a89bb13e53d270092619fae7c1646023ec43e47194151445dd76ed35d13dbfcd29e9eebbaf0e9b71c303f0034b8b5e645daafb8fa5b72cf2ac3087e88a968999109842f0ac935a118922ef7dc6bc37d9bd8c705e841c0c11590401ba973d6d8bd4c6a9466a16884cd02d3b4897322a03b59dd53ffeea8a27bb49790ccf2af2c7d4c539f319765fc2905e49dd25f7f4603ef3eeedc71c53a680bfca6e2632ccb2cdbd2a68a5f7ce6838a925c6fa21b5673f6637cb6dfad4243e0d687b8ebef54427c858408e73c6dc1c0519c3cbad88e104c2d06ee94c303bca9c720bcf1fee75c1aa5a2794aadac24e53b039e787b13e92bfd08dca5a7d51d2d6e94428a6eec77406d38f2f924d07ad71ab455824b8f5b6806b37ac41f369ade6910e269931e5bddd8400f890ed53b701468c9897445318042e06696692099914c875c60a9b294571653c8784a552351f033435c771d5b064f38d34caf42a1091c4d8cf08af83f5fd345c2aa913eff356511d53f9bdd6507bd61ca1d7bf0aa06e635262d49c3125f87a7c5a17fa919745d4d4391b1eda303bcee92fce7203830a056c0eb997463e7a12522f05751f410608609a8c50ab04045ffcf2b5962068d69bd630eda5bd053d5c2f4228a8846addd6c30396960eadfee0c1451c1e1d9c60ed781118de17318d38b1982277794727015e15556c07582e4f3ad6e836f2ab85c2c86fe3adeebae688c78d6db8c8e1824b113d807cc715e09b212a94b566cc8ce710624939a0eedf453c272d781579b11befff4b11432df2a7cd0b0107e71026a1493d9550ebec6b2e9fcc509953f19402d2fe1269cbee589ebe8aa3a5161c2ba7797bfaa3292671b5c5246a7fef39eae9b0d7daafe230e2f53926c4c916be4cc5298c3f0476a36263645c67117372c17ad36c73e45150a289f4a031ddedfa50e6973fd01842a9515e59ca0fd78a46e2835e1b059fb536356aafad374bd6c33a617de00fa4e8bd8d70004e3b9ef6f7a0a6296af259571511e0993b328df7d8036fb36c300524512d7c10984da6e49bcc3c19530cc23e6e87d1a5ff302fd6b7891d22c64941301a559911621a8e516f1f65ccc499b9eb6c2623ed57c1e11fd09d564c6d5aedb048e802fceff10040ac6f859541ab7ba0d54eef949057543265bfa6e42061b07c60d9c9c65c8c1bb87055016ea01aa2651720b4ee031b2223205c3e5438254d32059a41850597b1cc9630da49500bd4dc898c32b2286088ee3c35da5cef80d105b1ca6efc714de8df32add104bfc0f5aad9b641deff2b5af273e77c9f5c0e903f2fa4e75fadf3d19286b4f0a9d803ede00fda20f9f66f2a8809c0310fceca4209aa8b47119669e61f07604f47458f69320b7dd08cad2e14d927bf4222868029885275ae849d5efc89128dc711a5aa2429bb2aa721dbb77b8f9f6979c3db05659c209355032e5a8fef62b5d889b19d51c777c00e5d524bcc493f97a0eb4c3b435e2498516fdb2243c21961e57bfd8b3b32c129bd30c44c8a2aa2b59a823753c66d8457ca1e54444cab3f8e91ada9d8117d0441da2dea4be57d1c7a7b9f3fed6b173daecee42dcf5b1572ecf2d87d6e339fb17aefafe7e47508138f7b8ff76cb2d97d63a2138290393a732d690a0050faed2649067ba868726ee7d87efc46bc35c9b8002b9d17f923607680472c325a0e8711e075a4878fae81b0c29e6d3158b3bd6edf62d464d32f7da5cf938c9e2e9ee071ea0f7fae1f2a649155cf58d5250f01e8ae60db884a7c7e3259fe9913f1ed739527b07634c5a45165c5234ddc93bfa656c38b36fd3c441e728474c03e11455ec69e7a5e41261fa23821b84cfda03885b4080406b73f29b7daedbcac16ff146b5a3ac09ead502fb979502d9901077d9eaab550e37f04b4e138a1440ddc4d5409356a2d7188c29eb586839f16407e49cc945810b62341b02676f07c373bdf3ebc78b7d3c59f3ead350e0d048f37edf2069a29b01e93e33369c484b1f65212ec98292ec873a8a3b377f22183e1a3ea8860f10c79d827b1059a6675019fd4c6e89afa49caa4df79c260b8165c70efd24b9b9bcf0f0670bd916de4d56a5e62da3408d2071443dbc0810b08df8da973ee48bb56b2152790fc6d8c7f6691ef2ff338e6590df5cb8db11f7061ae0b866d9dd4099fc09ede26788861997bf1d45a17ddbb879a82273334fa7f564451f006fb77449e57ad633a296c99cf6688b78bb216a03083048e26d613ce3ed94fb923458c7cdb7f0efb3367aa75eb2e594b66f2131ce8dbd20d8de400d806e9477a9279274a3d0e226cbddab33ab3c6f74a37d02fa0fbb54735bca90a2b3a9706211724b1a6ce6a8af3d7859cff9daa45ea9efb331f4d9a32b8f62d320953221c64bae2af13c94755d1f49410fa2a449b72e305db7938d52fadf94b80faa0a748d4689b6c978d2033f386016c27198e6b9b9f528b9888099674c3de920b9a885386c1e37aaabfb984d105535bf4a4532cd7ed6f709f58216b087e2fdefd7fbace1934c5c8159458c1337e83f8b2ece7975f6a895a1fa220e78c7b7d2f0ad9b373d3123fbb0fb1fc02a1cc52485b557ce48bdb5516bb5b3a0bfe3fbccbf639ccb8cefed98d7628bddffbcd0c158f6ebf0a4f7b12b307118af953c5f6c6622c43c2ea68e4833fea38e2a3255f1bb309c8d508541a5dddb7a8a4253b66b060415f79f5742be9c4f2a3e023c929114de647e59cda1e405c6dac0a68a33330d379e2487166c67e329ffff5aa9bdfefea01831f9968e8d85423db184e397a0497d83f51d982fbd0d9b5d790646d6ee6dc8b1d3d4bbaa331aa5d7e929f9854a7fd20dcc2cfbbc9eb474af5e0b5de42f2c7a4ae415a6049f124001ebec33f70a247fb0eb244643d173a5e4fc1fe4d61979980be5668280a2687ea0c15ac19030cae4affb1ac0998c2543c8d29d95cb1e7ae1bee21246e3ee3251a7ae59cfe92e605a89c3f072f123f5c39a5f4d435d0a72177556f261abc51f6104dd7dffd24165711e4d4b9bab62d1e88ea8f78f4c8af8b1ba0cd2b2431ade4a4a2252480d9109662401683a82ed48e91d973cd7a05659ec220166d5538b5f636323638629a52a3ccc8c45f03c616aeb78e67f5e922348cb0213656649d975442783bf0ae2abb816018e551ab2ff7fdc5ccf01203b7786ef1c08f79c71f2221f6f318e40fcdab0641f7b7ed1cfbc1945f0a4819cb015520ed9c62d9dfd906c75f27f5a12919d61b6786decfe23916718b0372595b739fa08feed36227a027e4bd33a3681021c9b697131d592b2cfe8661dc72a53dcd259e0406b76b046532f45ca2b2fa06cdab6c0b63080d8ae529ccb15d25df32215156a5e082c6195c9e39f7dd441e3e7ed40582e5be3ba3a45c11393b5556b9a7741d8613ff6035a89bc29df9d7358ba8634d654842624aa69403b55afc62e26e406cebaab174e6a3d43cab67e2430d9d32cbca24a3b4be55f24bcd3e5f476623428b9146becce700eddcd7930ae80c38e1f1962255d2fda80bf1c5c5ad9e2c889e9ffba3e3e391f8d46ac5a2cce004f908321563b0f971ee9abd4a70d6bb13424df6f30430b0df444c0fbf145e4e0a1b3798cac778de2f04f6bfdbf201d692935956f4cc7bebcf59afb0847c4d6cd04793a17e9c931f53d74c053851b89decb0e5209e0c7f198172024af9b148d88eb6f692a27e958d10d958a2ab54cdfd3e7fb3a5d8a646d50044135df4841ad1a79ad9bef6a132a2af6c103c1b8ee41da84058a0b7505ae339cefc0d96067b8017839c991b3fa9e74973b4a5fe038d0537b9e934c1f33706172b2a0a175ba45988b95851b69d1786b4784ee22abfad0e9b8a04a51c934439e91f7540d155775a3a50f82f8ea7a89c0678f5b190873c3575bbb47a7fab3280d62cae8d14f8cc4be2b8730518675176234cc937737508279015d8392157fb10ff478ae8f98c5a5c93f9d8f3094a01f8ddbb5323d1d64916fa1e3ec955a2b2634b39825af984028e738668e9d457f638f9d896e58d8903de4ad3acddf04f14cb684541f75135eaa768f5037ae98b1c0dcfd675503842770aaf1350b6e208faa14ffa66f6e41ce302d171564b8286ee2a6347253d9d59829dac64741fde4de7a7dd448cb5b76ed2fd082f3295604e151e3f83bd5a941785950b1283c976adc788bd6fe59e9c62b75a1433b239b5c1e8278ddb7c2724d36b46bee5aede53ab5f4c50b77e8e61c83209a2478db67d45de4cd2f5d6f95123f29a0a19cef2a0cc8a5afb6d9193b9feda164e4a7a769b26e1304dc5b7f08135a8fbfe323c40dadf96dc997eb97cec00c139472cf8b946ecbba438456b36ccd3e696ebec0a449d4f11d3d3feed0705cd55d178d4cdbbf111e69beb44cb43c1ab6d709d2caa547c4a93d57b077ea57545b138bbb9bd7bb00a78e557d3fb95790a19a8df77c5d2c960871e3994ce289efd287072214dda0e9afe171125f81a2f6022d84c24af52e5e41740a64999c3083a3f4b41dcaf59406d1a2a09606ef93fb5b7f0f1a27ab0a0db0a37f0b3e26a94cd72dd4d2a4495210b3b09125c9fd3582716327579d9e335dd163420dfdc429a760890c2a6e3a2a0f2d641cbbe27fddabedefffe7067542c078b79021b839124251478ab3ae5e9a6871b13c26bfd10f208f6b70afe7c8185518adb73cf28927d9d74948e5eb8715e3b1f2736dbd5e553f74a0c23fcfaf0e77077f2f73563db80bc10c58a1ff397c34a2d4f1936cf51e7f0ae89c598ee7cbe5fc53dda458a0a8899e271fe05539df5aac67a2f67fd3eb4f","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"59ac2422926ccd7b7e7df71b97799db8"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
