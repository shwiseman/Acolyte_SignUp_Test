<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>SVSC Acolyte Availability</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Acolyte Sign-Up Form</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="CONTINUE" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f1651c9b1c0611c0c38e64518894e3d1e119e6ca487b463261c23748784a530574f1e1df8182b0104591438b23075ba95dc70929a3cfb55abf9b06ae0ac7c057e32fd86f8ad3911940a0b84be7943a1f9cae51de75c5577e376077225f0ce508d78679a9507f77c536d1e29f7915bbe883683478565012a8141d3c9a595c8d62abea62da6072b675b80f357915be207197797e475a113fbe69a72166f8209298d71172d9efb1be805d84a7ad15a6314da4d70631ef7e6123880fc5d1146c2f09b7cf51c6378df999173397f9c915778cacbbee4664a26549b457cf9f33f90a08075c6caa93bf54a6f5734f7337c754465aac8574fe95ed21f14106b4e3c2cde6ff78367d12178803122cc78be66a7dbe916904c97857449624692f351a036ee9c553987bc56c7e19e0dc2e5341e45c10af02784ff501afcabc8891703a0c861f1981de1b846a4aa112f26d4ed47121d8f71e3c30e5d559d09db0105287d0e2e429c83897a96220d50f8c75c5485e696a69a99059a450c0785b87daef5204118557db186c8faded0e72b3c4d4c7cd3b229c3473d37c510caf006c6c95404d665044fc07f143cb5854e2ec0ec40ccccb9ad0dad95e28236fd371a79c2ce817be242423eed9a4754157ac4e3407abf2084c67bb94df246f9d2a07c17fcf0157d79bd1af2dfda8e1cfd8246e25b7bea0d5f2eb03f97a4ae59dfcf9722c1e621e560ee32ce786a23184b59cfc24c9d399783d2693ebd2f062f70d5acdca3e46c80781130233a10a45b9c6959db9014daa28856729c1a8f8c05a89de7e6788c1bf1df36192a850d9cf93291bce2a4b94f8a09f9dfbbda15e3e535699ae580690451f367bc8d7043d22f9f666cf604dbab123b287425885b8f8aa3e710fc8eefc3d9b140faae293d6857a1ad9dd601b5fe553136a05f0c67ad17f042a88d5cc67f461533779e7561c986d5fb4a918b3ccbab4354b5de222661a8e3fe889fd988bbc1604c4e8e9b239ea69d838bfffa960632855b207e6bb61960a3b507425e3a02bbd5482e5694a746afcdc5e8222820b7549e502c7b7a3e2d739610f5f350c4fe8a9e6e436e123a284a65e4e9edd9da5a6674816ac2ee5c2465c1ca89e4ad25f4c4c2e88d15fcd0c8678692e32738b22b895bffb006ed4b9f2aa34ce2494d29c1e709c15922cf67a22142540f9a1dfe6abe394fa231191398b5d396a1350ac5ab68b533797475c8dff5ac6bd1e6a04383795589234fba881eedb4addd1e91cca41772c959ab1ebc6a1971c676633c9383c84b9a79cbc941f65662eea10d323285baf4e2c4aac33d3387eeed2aeba5fd5a88606f7b40ad4d51932bc4f5c04fbadac4e753e5c9612539ec173f1149eb57c4727b066d0499f38cf22d914a45afeec2eb23b2903d64ceeb166a6462364a79e571fcb4d35d60b3dfd90ae3bde242372021f6b983b5bf6521f7d04faa3ebfb1ea149d3e78b59e60e433ee2cac0a12f7654c7a32606489fab4b9ea4849af80c2cb66d692278210c40eced3514e64cdd183d5476d1c1bf7274f9b5ff959b37b01a66f23e403eef37bc57dd2fbb171d156a8127c2f2dd79e4be335805f3806b2cbdff17f0b224d71eb149b9421db1e676accfc63e085aac34bc6a333e0d4a956a928fa06cd215016811e3ebc804880ad8a0cdb5397f7c26a5230f73bf95f0ee001fe4ac06c00249dce06891e3d9a1af80de81d8efa30952aa240e13e8222ae89180a9f201d196eb51c48dd6bd97190cb6d144fd6cc594ff9e3a7169109852bd1dcef6d68a6a496f8765348b3f65c2a72461f615d471a44d9404f2a7b9a431377283e4117126bc5b6c0f55b8d14ce9a3be4814d27f6e5f0e315b27d0c2c084d4112c69b5bb965085845081968897a6d22b6df363bae0175f113ea81a19d2c9d993971bf44c34f16f88a785ff32a052a6d37f0199aa5860b1ad4b4ef71e4687df02f694dc4a12e8bf453efca01e6fefac071ae4a199a1b272d1ec669b61ba04777cf29a2aa8a34a53b530e7c85a1dcbcb43846ee63b5124452d380b71ec43ddc1d15fc48b151c7d2a22004d38703d66c9db4e9d3ce59eac2419e752a08fcc61de2cafff6b7192dac07777198d0a82458575017524b1ed7f9cbdbff1efde40a4d33f46c3e412e5c5760f4bee312631dbe3fdb8fb48c29a3b9831c1c94dbb033df426fa7ca8fa75ae6ad9fa514c6220d755640d0f16adccf46b30ff99685faae5164b3593274c29971f78d6fdcbc76838104c2e35c6ecb9ceadfe6b01fc89913645378464556f770ef1e05ceb817ebb8b1a72a942b9c0912fefc8d5efdb6f727063401063313a141f04a78d9f49a4fde054b1b31e7ae1f03c17084b2f60e0b82bece876bf600da3b76b3ead1946cd0dd9081ad7c608a99c8484af4a240e31ead48b271fdb38a42279fec55e24328937e3f159739f8cc6d827aa3d4ba03d468f4cb6e5eb3e7a611584fa9fc1a1e88a1170424056991b43fbcc094329d007d24233b890e5fe2700b5e0109fad3373492015ce85de7cdce17326e56f79abb1fb0ec67acbc9b7cb50242c4e207df32073fb3c09bd85c8bfbcf9c4ea4cb930213aed21c1a74371fda8ef025745438f82deb45bfa8fa79d1c8243298ed56f4f7131cf0e607a2a95782e8cb9ab83efa44c3fe0f15008166bcdfd16224658bb778ba9cbe3dd9c3265e92155338c56f124d55056e6c51815250c859ccff7ae78824f3d2268be9b6378e2f61d50b3552c4e5250108775007f92859065de6cc05ece2de6c97b282f09dd857f67c0222b61f2c5aebfe4d457909539a8b21ca3637c8312157db8006f53def831f1bbc7a2ddad2b6f8579d6428debe2624127e503641003d52efc90733587be379750c74e0b100ae0495a2b20db22788fa4ef36883bd164bb442336c6dffb36d1573155d0772d6f2a906cc7331e1ab57ce9a4bf5966afa3685feb16b5b0072c0d13048299ab20a6b7f9b9d8bb71c9e92ce451169a46d8415a520bbd0c264d020836dfa008837f38c8819deb1351af099b68639dfbabade823168894fc505c4fd9b60fed4f6f73cdb42a4fcfac16f42d6199065c0f8edada3062a9ddeaa7f98b94067affdc1b5f91b6694dd4359a6ccdbd168d3a900c6bcb35537d28b2d33a7864a449f3d1206489622c680d96328f24cfe5d64fd59e316599a05517c68f96f41341345e7446a40069cb593a020358279a5c93d0d579da44e08c920f658ff768d83b9348e5a81ae88ad5c1544fe03fe411adbc137312aacc660896f30932f4c595f78ec50b0fec1738d6af775740b80de52cec689f5e7ceed356144cf9f388cf933085cac139d465ee2011d150a68d666202b72ef94e47b8155fb63e3b58de8fd7a4535d9c7f8d5d1b1b0248562b00014a9e7385e700a160fc311b3b1adf6eb78b23eeadd98552494661726e0ea7ab10a002dd3bff62ec79be159ac5faf23af1edadc6c24c87cb0c56cebe303ca8d88d22f439ceb4293055f45eca3bd114f68ba69c712f0abd58ed787e58d853e49337114025beaf54419615bcc93dba2371691624d8af38efc6617e99932bc3df328d7bf0994be9fd6f646758a503d609ea00f25b75ab5ab24b6456acb62b8920616f48cfb955b597e51edf44724bff69bdf20da47816811bb6192dfe85e793baf9c371b378fe54a04b3a4f33e2387156ac8832f0935b5c3f434a5cfd7a991cc6c87411fa6564b4c5cdf4db20b2401d33932a22b14edd2468fe25ca344b25c30734538160d76940ec9c218552b398fca41f9926f549d2a00d45a3acbc7ffb688acd19779d5e032e7f82e447e80648ed01b624869ee813c07dae449d43a614ddfa50f7f0618b18f076e4ebfe8c59fd6bc45ee5d5e856cd902d286fde7d66f9d5ce11c7fdc54fc2429a8d368baf228ffbc23e2b900dc93ef85f6300dd3db6e2f453784d545db89e7cd4f7db3dfef1e2a4950524129518c28757dd14f382a49ffa04237a96f4de03bf5714a838489eaa2b88ab88fe60591551692e57ab3757222cf0e1acf1e8dfdf4e340cb8ddb238eee1b26d9ba7d4f42662ee93185bf9cd5cba25b38b5412da97509b128b9a012c7074f9672323e7b10ec0bff278a54e492434f10f1efdfc9ed294624305a4cd58108d0f9728ee0310bac12c1d9bf8311067bc019238e8012d8ae75db6b8e2dcbc03a0607d676443c0397af8d843f0558687b06dbe3851432637354af391557e435d9e11b41637129621557bd1f35ef20fc34d17f4c59fe2f76770074a1f75a5cb1bf21395ec3d230fa0f93053cb945fa88646eb7462a3c9a93a3cab0b9fa8c5515c956a6c3c7ce1b603d778557e0c09171bec20ade2bb3b25033fd117d745b262d48e64694eb1e886f8f543b95da6fbbcf3e398d612c420b0bb3b0aee834c5f32520479d8647c168122d8f6957d5039a308b05067862bac8457f62191748c7c6af0324761c149deeb5ae3bf8b1a0e1ff28587d40480e1594b986ebbac2e2d6b177ad23e224f7479ea4d422622fe252002322ac01344755b7c59c49a14b11e39d0c5b14b2049b54c254ca290b917951780c4b0cd8bc2f2da950d3c3013c34159905f43000ffceed8a24fb59cfa6757cbb182bb883b8a0f1de0d44620d8e7c4adad0571df37ac791971ef49c2ffff034a5feee4372285db500f0dcb4662cbec72f66df7d089e40d16f0ac7f3395cdca8dd5b51436e06e67844e12a8671d496426bd23433cd939ce4d3e826777b07e6c428d59c80db9b3280e42e74b4b384c7b35c55d837183954512314f0be5a980658091dbf399f1603cc12f485e59ae7b30c97ab31877ff8c46648432d4adeab10eb895b66b82c3dab3e4f3fc50b4f5b09ed436c908b6b131c5f7e2103dc492e26052474ef7ba2cfc0e233ee862970a8fce718151fbac5f2a7759d5bf060054e3735790cd2c722c81fcbb1a535d794dc2f4f1b53c430cfbdeb42f47c00e9922f92640634e244a574af1cfd7a25c9f3937a6edc0706d7a808b44af0e69f0f138d503d4eafcefe610481ea07ebff87d7a2b8699bb889adf192825d59a3d9d7ed789d8a40380685e199d19c907f17eaa48133797c8732a74c533c9aca2cd60a5e37d9eedc4a93ae8a78162ef903397de32cf2710f45d4323b833dd2a1ae4792957d2e3903c9fb71f9c20bf58b97ae015d3526acd4159a822bd6525026c7b27b3b870e757ad320db56576eac1559400a80ed7f4ec2e424c4c2c44b43f0269d6bf6625983dfba7d973890756c32123ec6c0bead2e3eb07d4b61409636a98499da06c05af67b03edc276c5ff39ff7448a7ba7f3a2ec9386d8e7ea7528c232af761d895481eb69200b4631929e2023628df93be9cfd86dfcea02ed94d5534088b18c27c9487c74108e64b4fe3202675b2ced0096f5ddc3ad7029f640da382ca420e4b8f254a4b208abbed46452a1132a52c4f8b1218e4e507151701a0e696d2d69920caa80839609f78c99d86beadb1880a14ff513511a82c4a276ff9b4f1a3f21207f06413e81badd643787694bbb86652447bc9a25ab2bc8d10b24c83ac8462bd6001e73bf8006bb0db40e2e5e62c5ef6eea3f514a4dbe5ba480a762cc140f011485ac53f97b0dd5918576320810cee113bfcdf0c7c141ad44a2a4323dfd57ccdbf71c84ea4cd6137edfa9c13400eebad8410b4a92646b21972e38e19b826f606b9e02322a1f0e94dcbb7d05c9107b2200abf739e41ce3d928cec88ccfe674e7f2495e42bee966ce1497136bbb421caec44e923758b6e2c751e3c235521aacc6a4ab8f023823b2bd2780d58cf45cac86da9d85ad44f1b68bfe186776d2d99fd7851c3d040a842e3a7c8ad7b8f984047d8a29a4085a7f4367555ef567969989cfc102c5d598f62a6c4ce6d50ee5966204a537ce967ecf0d80f3268b236c561b887bd1dec9ffb5e5a646469407af59dffb89ace0763e1b0ca03c8a48c53006bbc38f01b43904ba6b1e801b027c76f540820337e91d8166bdf33a8697f4225a69100eda5cd987a8a1bc4f13d8ff62a155b7e0d7f8e544e6cd9a814452d727994bfdb3cf0d86b91cf7b80662cd5e3bb473fa2afd85f18771c6e95b35046ef82c6c077713917805944f4180a6b264e4dec41d9c68f8edbb6cd3f1daf8b1ad33fdcc88ced81a55cac8a6a2d2e3be7d536896509736bb061f9f374e4ebf2231f2811076e81e65adcfc0ebc98d0f026abd85bb838b423c0418101cb8421c229c165da51dfc675684238d53d98c53a40a7ec6e1a6a99a14934ded3c2cb8ce989ea9d91e892fcef6d0c7a1501979d4af630b20dbe5e5c3dc5da1625c0ba5dc7588678ba585867f9f3996d5bc30ea063c3ad9e56a1b682f9835a27a3b848f4f2afc25f38f0d79dff7c2749717d230caa67d7a5d41ad6feb6490ecf953db6937e7f54e4d35c0881d981b1a8489414a00b2fe8b6036e0eeef3fed5bc24e077549b8feed35309469cd5caa5eae0cc2e1399599f3c9070179e4e5f97e0b01d90f5282637eaddf0a3c27b796e65e3dd947176c353d804dfa01fe1c0be17e6c83027b90bf24318c5bc3f51c95418a0f3825f803cf7d40b0283a0eb9ac1ccd9a6d7783c10fdac7f9c4c28c8ca019faf342c2f612fd371060f09d275a67d6caeeea75e735b0b9c7bda3b3a6c3fe68e2038adb2dbe525a6897f878ee70ad0b5a09d4fa6d955560294cc5fd9a72315b8d25c81b41f29a59cb2cf9d4da0c75bc3c34a920bc02f827c0bd2c855b6ec7ff3063befbf31da39ace9b96fc5540aaa9aba4e8ca35482d8708ce9df41c58abe8fa6a65268ccb0a945ea12357189533b21a49dc5da4ddd083530f961baad63d063c37944616b670ccdf264d8eef05070ed06885a064e6a0bdd45202593b42d95752b0f3723d4b047776a0cd49c7810d1a76b87a105934e29859071f23c14397d4092d2498311a81637106d2f1ad48cdf6b09ba410387f98f22313fd5fff3bcc6cba7333a4dd1e65ba8f24c1ea844c526a66363e55c6392bf57473d9d69391a77b831731729952fbf44a35f491cf888c1380c0416af09d410549ef10e31c089713d3c39202db12ab4f71053552e850375378d18505a9e6d280f26cbb9c08c92c36c33ef5ad043c2dbb6ca9ce78f519bd8a72db713730598e1cbe7b596bdebd4051b601b030f2f08a00edd62288bc46220251241e9ad9873952c57dcb7527371ce6a0932a8ecd4368d2e1e5dedff30db48da5b258ab83927846d7f7cd5c7206b98a67994c4735e9c38f44010d20f25b4aec30a78219f65673fdfbea6fdb2362cfeddcc290d138b1926e9a28afe6445cf6a89666e7ab08cded4d3e3e4604fac0580f3f982de39135d8a62cdea8a584f3c4ccd91a79491a23b75a1cc750bd6fff69054b6d740e75782d7a1d1d8c541632054db4030dd905cf992a3729fa5038b09587eb47e286affe181d1b456fa2cec8b03c3c223318af3308f116a7334a3f9a0872c9e036660bfa6403c175ca08fbda6fd2ae687147956ba19b4db45f855b3b8f9292195613029f16604bcd1684f770ee9813709e52b79642c2441b75d273022b137152d2aa90ee1e580a802fca1ee70aa791329cd5c134c6a823ec4d5582b4f7e5ad83bc182be95a3f95b409440ed84cd02540db83b7cbf0","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"fd4c36a461f0ba9e9b01e468a727a0e9"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
