<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>SVSC Acolyte Availability</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #ffffff;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Acolyte Sign-Up Form</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="CONTINUE" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"aecf786eb52c26054fa3dcfbd955bb495e7b351d8ce2f3ad2d660d1b8bde6cbac31a2bc18b65882e1b8957d1ddded25878cd01f06a24e161f17aa924b61c08ab557bf7c26abd536eba1451a61961396ce3dfe30fb9531c649b75feaf7b4fa38b31491564164dd8eee5c6f8fb7ada427efa8d09e287dbe0006fb83c4270dae072942aff0ccbbe1e06a6c9b1de17b87a51399d2713248bd34ff142a8392f0e9ee0ccd2d765a00604dc3c257f85cd96c26ba3fe7b82e99c613f4dc029f931b3041d282615b63c2d4e2f22fe76cd1d26700cbf8dd6567ad92f7cb488cdf539ceb5464b0cb9b6f41eb1c42f8a83b1b50e62a464e25bc40a440163e0dd6cc5962e576ebe1889f3f288b25cd1cd3e1048fcfd93abb68654066b10b59ed0ae20bd90164b4c4e5ce0aa810cb399ac5f6629b212eedf78b669355aa35ffacef73e49e5950dbc42ac39918fc62e1dd79d5cccdba637ad1f06f61d941dc17893c236f431794dcdef1340a84056e2924832f9d165d6ad138d6ddf2d1086bb6be12d7212d1de109666fda7af8a6df7932ca50559d9cfd691790789e6f10a6f58dc7849f634dc4839d49c5743b68b38d60ee7428c38ec333f07c7380c93273edac18ba16c0a44c5d96e2b793fa9d4f221d6fc22fee80a191eb01ece3f06972a7750edb31dcae4c9a02253fa59d597671cfbc80e83978b150fede310b3d8364f137574d87a222389208c647f5e1a75da6cb0b38501c07dfe534b914e3fdb36b55187164c3c1e8ea5c067bbe36e24f8974b53e541ce88c84a20e9e99df7b51dbedfc2269ad3bb6947a29b55530280059419e87e79905fd4c92af2d7747367e800d4434e79cb4cf0596c25edcbd1860a03d342f53ad702bf8b142c45c1a9c96535873a84106f6899cabf72038c1abe80f9bb7482b00a8dd1f79d4a7f05b86cef8550b95827ebb3e0ce87d5a4526db4742cc84e2e4b87359642b81e7f3b8eaf0e3e7cddac5943d517aa4aabb14ebe41fb80846d76f08f571d531b93a2ace590b1281bfb368b5450fa046dd8e850def4e32a79a00b4d8e6801448dcb67f62676ccba22288d573640bdb28b707bb0bb2509aa93ff7fdace0132c73ba80acfee84676776e05b349e48a7ea148f151b2e8b9541f57080bc46dc6764305093414b9df746fb3315b843e2dbf0edaa6bc57e10fccb9a4d9a0da919114d8aa3f811a92d8cbae7fc8f727a1b0720f10e5810fcb5bf2dae97024b5f512f2a33bc34f6a86bd6d6357ab5d1197d4ae2e7caa78f72163c1c228d77fdcd649b202cd5f230fbbcc655eae89a317c83b0d7a027bf257e6f9f1c4fed737cc8dde2ebcc047fd6bded4e57d1fbe7c4925183729de227b5abf1cd8195438cc221166924c435149625ee6f2d4f0cc301f77bbccf70d269acabf3d5bb1dfe88bf26069d256462cba4ec70a4461ba77c410a41d4f0da43eec6b2279b393c1efae2231dd14da50311f4e3e405454145c2013919308793fef86135759d3a63a98062772140cf4cb30fba1e39e33722b227a7657a8e6fc610b8d562f557a0bd3d1e55d0a37def64b3f423e317991372ce19619314afade84a57ff494a6fb0e3676596aeb33a6cd71484c0ed13bc08183c96a87c77269c76bdb17480f2eb215263b9833aa78c24a41f2c252c59fe71176a7797b1b44aeefdba1c9412fb8e8e02fa8035fa9f77fca395fb6372e53d13fe1db5e516becd9fd0217f7186262f4954c91cf0f441e68ade9080fa2045a96da72a469694a753d56352d14787e3b81ca4fe60c510a38e4fc5b44d355d3f46055dca4524d926e8ac275fe1757f9d36397872f3e8746cbff59d8ce1e5bfdd67ef62e22f92aecc3e1b2c3afc8a8e7bc614ea6f031c7ed9a25c8ae1fd2c44d8b1c43a2040eacb0b0fca0c3d229f13cefdba6b0ea1bee1a041b33c7eca6f87c5056967ebc0e5978417bb831eccef1075d1f9b577d0fc766b15062afad0311bd1aeb79b2e1f03895e0dfc86ba1893c494435e68da95260b26f3fa7dd75a3b95742a2aad947d5eaf47c3b46870f545e7ab871d45a3ca826b44f54964f2ac92735eb8c71db45cbb4a91c9e76be750b2c071b7934a1682ceb79076e3060f0166a93ac79712bf9f5895ee1b975b20c1ad452b14b547571b5522ab9d0c70b8ccf13c4f55d65c57292812e4d5d1a60d4f152325aa7dbe661253d3be639f0e26b98090ffa34763927ab409e34e5e331d539b3ef2ed04de7ea0ffeab924d6f1ad35a1c1a382b9e629035357cc6bd0f0c8972603e975ead36144c1e19a195df5a34bf39b722a0052261322571a815224a39ec2d0ca1ec1148457d0357d950d3ca7a94560b8ac8c2f42c23009d24055d26a70a58ef01c77360cba6a487473ccd9eda844128ca6b4f918ad513b29e269ead2a486b7c2ba3e265e45973ba269354c55b056b2ed466ea2c559326cff61a6a049d6379d19b5d03f247003eafffbc42063f5cf1e2fa5a3a0aa32dcca55ffb299557603ea81fab614d8a585b608ed01ca09d2c407b1c8d96f5540ea65eb0d0c3f3f0f76c583f6ef460f67918cc74dadbe8788b74936356859e8f1c784e473b29b9f27702528bfd5991dad410a8d6c74bd507f636b8ebe266a6f989e9bce1d649261d3460091705c058d9b4a425f05f4e8431dee09db3fc4063d8d601befb65d016eaa38b1e4740890e16bd7ce0dbf89127a59d7e303f1c4bd35229b0d6d77a0e0a84f556315b061f5c9d3ccf00c985c784ccb3d30ee7b6185ffc24cd78153a84d877e8f626e4c3e0099b56c747411b1905228c2f1d01cdfcecc397ef006ce9b057af284cc0f77b07ac161a8c8da404776c14e654f9a3c6f9e15ce3181547039be36f68cde2c8281021d00b6652a508ab8dce4e8ac2b39b6af33a27616d1f8401e4177e076740e5131a56acc6286323f61342f163de0a39ff7a7f48eb052ab2e3bb420ed788177e2b401528ea6c05618194b1c02d0e9bbb0a130882b2ef19826952fbbf427fb1fe2a84642a9e3b1141535cb92d474eb16bdb1d33397781417eef04b8d2f1b6d4ea8d982a2d62a1bc1c0ae2add0d04e58dfb111c474d7a7ac4bfa43483e17f6341591969232404b45d4407a711c9ea519792a86d61c8da1c76bd100edbead30bbd276d0eaa88cd20e753bb99026285b677d6f03b038950ce359f1f0f5531ea9bc22ce9aeb192b3bd9ba45368ded561cffb7a7b4bec510778ac4bf0edd6788e968b7ad63ad221294bf301d84a87496e37a8b69d24a645d8fd8151229bed31ab91e70117dd878099170dc6c599858c2747fb6544878052cc2a8ff33bca89569b0fee03649fd23a8f799ab76f54fb5fd2a939d9dc7cf39b56bb1ce4b482321cb003c77130aede18f5f58d5c5692c94a57022b03009fbaa03e85544cd3bce2e2fb863d773edaf05e6363869c532d13bf05eaa695cc473a60e00ac2d28b8fd7d6ed8303108a2f044f754ce1a6e2580083ede06a136e350c071b9e025dba004b522e1be75abbab97ba54ea8c73552c5c6cb2dfd87ca9bd04dc9e40f0238250790fe32aa51efaad451b307718956579c2f2cc77a0538c82c1b2069667c825a8d93fc8a172f0b729745ebf999905cb11490189c2b25dd5e7c288f48f54da2de876a92221449aba320ee02b65d7a2d6572676213abae829f631b6332f622e6088f5720dc180c8241268aede2340be531d4b6d2cec9eaeae47895d1db295021215e6df317f8ca7ae196b176134a6d655171ac351bd4d9949b5c0c8cfb026fc5507c4a7109f448b77dc47e7b9a098c903a82c0313a19e313c238fc8cce777a39ce076a5fec015d86bc37ef77516f0af6ac742a3ffde7debcc37ccd9a337360eaf870021e9cf67691aa91501d8f921330437b7454dc1be23741f507e90b60af03effd7074b93a3eb3802aa816daea139e8b73fae616da6720de8e530624624e4e4862f4e5ac37121a5cc24a020b338f04ae3f7d330d12acfa6821b7dab5e3ec7afbecaefb8be4b0934d778bb75fc4bb8c57a1098309e2625d60e9ce635311697ae7fdac931c0fab47d069ade67589b19dd806ef2e4f6b0ff0dd5017f860c079d265ef2db25510581b55143f502ef34318a05a0c55b95a3204f5786f84f3156ac9b02cb32b0c325c62a0e1972292833fd25e3f336a5b03f7ddab4ce645f47842ff8e5398d84fc00286bef17c2171abf024d0b3c86e8c795d40811c4c1bd10f8c87b4e581f5516d00686f7fdc9896d9192eb5befbd8032c4339f207bb29be11d378d157f9087064704886fb7c779214b9fecdefbe33e043ad1cbefb5ba40b313cd301a1ce90b605198b280599959c4a5dec151b7b1d191712d1f25a20693ed478f38cb76ef8276b2f1eb80c3d4658b33ba9a38bb30c63e5871c07438099bc6f6384f0861027ae084632c681c75b06188b6a581805108fc34b795360838b7149190db309cd957542bfd75c790e930e35a0e962fa818b27eee0991824cc2e5ccccd50ae801d25c4211a68983ae3a3bb44e659c50cb28e70c130b8198a19ea7faadf1e9bc27b42aaa9452c2c24e14fad8443a7b67ece1e50b42442d3535688accb68abfeef7641365cef9d042c8a50dca2388a55a5b97ceab552260b91c547649feca3fd3350ec622327398f3378df18d8c4b92f28d5eebd39c962d96af3a35f6df7017fdc8978115b067176a1766754bc31acb4a696f029fd4dd8abbab2823af2916e899e0b3a768dc3637b30f67fd178149be32342c99fd5c5c29270e0f37578dd40deb9cbd904bdd8ffb2a5a04d2e584f4da9bcf55282f426587e6ba8e634ce81f8f5e92bdc7e297767b51a0d2adddc866bd8611cb752dba7a20dd4fd536e29776c7ea250b9ec6619dac6056b9a0a7c583f20496ec74db6b42e1cdb0803bfa65003912c78ca4396dc1c64884a9ea8aca046eba8bc220c3e31548256c9f502989f52f24a2f88059b3eb30904c97cffdfa8943ded45b5ef865e5285c43e24458f5dcb58bbf79593983c7064bf3fb3dee40d9a4c61dc3920ff945ff68adc2a8cff533c2c16f5bcd00f26e00c82db03d17b67d8918352aabf0e48cd98656d779423b45d22cf95d074acda2158aba9a796e19b77e26131112b545b3d4af1a63082f7e8881ee563eb320ae3493c94152cad72a460d7df8926de0640da8b003117b40b3be9a58a4b6ba80cad09aee26ed30be93abc81b618a70ef1b28c3398ec4b11ef0f58d9f85f6f4a22002405aa1a5469afbbb4d0cf77eacce4df2f8a3ed25d81b81dda5ff6cbdc8e58d6b41c711ca18e2d28abad4661448881b87388dd7f2298f568598b9b34d40be5a1c329ad095ab6275bd0a80fb6e2adc313861fe02807a269f017bf67c6533d271a57f878f6549da29f63bee7927d4d8b836389304a845ee727798ad7cabe987b454713764a94b896888270b2413234cef3226ccada173949779e0675ed678f5b3ec357bc7eeb58df23f2bd69abbdbbfdae521bbb34088782c98cec069fd890af9c7beb88a43ca75e7e7bb3de8235ef0b6937024ae359c5809f9dc6d880a51f78e36868f99ba1e599338df8ee493c1e3285063f29a4417449f617eede7a1c605d73e6b221585d7fe00771a7e2702223f4d6a5a717b7b3f6004e0c677036e1661b7caf238eaa99777203f0370ff116f67c7ae141d55e2890f01ce93ee6f32b328171fd962182b5a6c93d2282e7aad4e4aae537487c45fc0318c1f73f7becdf570fb6af15b21cfb144c156bba26e4f074faef3d660e2dd34a9831d7d084d63df3e9d136a5f481b2e24185973d8ea8029768c64057b74af01d2d39615028fe2d853aee3622992ec25e3c1fc71ba3d44736748d6eeacb8238fd16dc172b971004311962692f16e2a58e29dd2af7ed9ec716dbbfe092499a109c2d1b979189990299efe322f2515f4d0dcd56afcf021c93082965cc31dee422c941218977587c4e35076bdf6c8f0295481f3415c0f4586440d710a9a92cffc7868761300580e008a6284be3b7b65a3052b9b898a94b1f9a50efa1e4db00d8a23e667591ff1281c1a8ce3a684be63985b403615f9c73d79c2af63e11c98aea5602de073e04563a6ccfa58224a874b394c5d3f96a78a2eb42a64d56d48b915841f797f3ede62fc893185dbbbd74fc77cd80b5b2562c94f20dbc87e4ab4422432f0179a5df12dc213cbc775198c374f2c84ef39896a02d77be4faed1e2ac8719e1c802aea23263f06b577b5723f71f8155a16859f4924b1c7224f982a391eee8c4095a9aa2d8c69f5e3cc8bdb8e0a6f9fe8a69ecc2c80245e14e7c9b9626357264dbbe56c39e349f14300da4754b983e428512917c763f1b269c8ab636595821e614dfd2e3c83dd551a6097b7e2db1362d771c0dbe03308e00aac177563599b2f7b65818c2eab7b1502777f7336bec62a461ad9c83b68401560a72a5d5c16932ced16f1c3f21878b3edcec1f79ccb9d10ccf1aa3e2f6fc39b26e1badbd0ea4324ac0f19407e13e1988636087cfc3009d0278d2099ab7de2858c693487b0ac058e7a60499075d89e757f11f57c9316b45c43384d115500480de9e5a83110b419a75a8d484718fd65d938edb43150690bba7f56e2ef01e27fd708ee0074dd7c53ac711e9b8053c4ed0d3378dc5d6fb244048e0c34e73257faea622df6b034561c4a8afbeae4cbd7bb142d9aa762526b9aa63c7d5e949c56b610167de9e38f25e8dc699cbf9772eb8a7679667b56474184c403d4b7e7724e962fd14e8866e5b1e102ad88d2e6e89df8ca686c8a23ed9b7d86db500c5baa2b633cd42217ced875cfbf3a90e0cdd8f8786ede0fb15f5898847aaf6f139381a5fa1e805daf7a898f053a20d3d63b147dd31fadff06952901fa3314354936cb1f10a93e349b31031381fffc75727e631f3faa658e6ea1eb09f556f6a32f8d52d11c4ef351e2a6ef5eb864739c37c191fe4551900ab3c77bf44c838c82e87520ed2d6b83f7c9eae0667ee9b476d8c7415f169e49d683d95722f22dc8db7439727e424db7658e1414e90f0aa1aace506e020c25af86c85e4cc5c7adb464255de7aa9ce5a1a4977c4f82b484731131c97ae9621eea3512cd04d750835669ef314e1439e96d1e7275f044875bb0ce92781026a32b861b8a4f02aff386572f5841d8512b4e04373ba7dafc4e13bbcb214a1fe915f74ed7fd73729a195ecb77c7bcc85fe8175af44f9d28b96fc5efc176c57158e3d7a1f95980a7659bd6a7da7ea1adf6ba0b507368d191e08d2cf679a8ff912dbe2b69d3a2791bc6a5c981713c425170aac8de56d618ef6ba135baec034ecf928c75990053cb2fe0633e71d627fb4791fbe3dae0578d2d429da5a92f779f35f6eb1f9a7bcaaeab48b93a8018e7ec01d0698407fc765fe65b9b6f5332315867a251ea175f910e5fc2f57fc89e1d3ac981befe0fa9731daca6d1c78ce42d6ccba6ee78a78be18c86c60f78a2fdeb6d0cbcdc0a0e498993de40768474fa0c53a985f2f2f70f3a135f7b7c15928cb0700507bb93c323b1bd6928f2e3d17b724570b59969fcba6c8a0871cb28eda39160ba32d7a17c1c602dcfde7c5803b32d19067437025e6c8d58a6075733490db096bebcea26e90822b54a9980c0c49384ddee620c1f380055be1ad6cb42eb758e993bba7a3b009c74aa4fbeef4df0b4f5f8641dee01c383abc06aaa363a3e75f0c53ca08ac5dbf5eb92da00bc590b619790eb61700c8102e850e4dbbb491fdb0f9b","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"eda910e8c9cddc9fa07161af5dd715a3"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
