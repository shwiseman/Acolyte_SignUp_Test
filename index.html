<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>SVSC Acolyte Availability</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #FFFFFF;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">SVSC Acolyte Availability</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="CONTINUE" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = false,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"6f806352056c611960036843f2a9bff1232117f7f78998078ac84934b792d552bc2c662a6af5aa7f8cf6f49633e0c3cf9ac6e068ce9450ce0f2e3f73f38f0bcca9271c96074d17d5001d0f3770754a0f918e0ef29bfaf4004f817d4a8a702f5032108f310b53033975d33fd86f8c445c81822c9e25a3d3e294fcea1e17bfb0e013e040113836cd0e74b69490c1a74ae384b897b2198e7ed64582975c1b1be75e19ffe82c3f67c3a56febaf1634cbce4f7c33981bc924b5afdee4241d23108fd12627faa7204771c4526cdfa2305adba04db3d5b9099d19dd3f26627ad39dc45ee2466f434f2319dee1eca2e8c38003b3834ff98e323a3a2eb11c2173ce9691ad4ed36ac3cee206fb7b8ecef415caa577429451ed44833f4d85ab855104683e7b7963cc5324bbf316d89d6e85816918aba79cd36c2d814491e563ccfcadc343586ae78fa28a43532fc6d4054a11c084b35cfe4a8c85b145beae9e52bde0baf57b89f1162bfc48b7a111ec601d860971519537ca1896e95a94541d6bd1371009a6327ac45566fb16e89f11f07c249694c1172a5f25b8319996b7e62fa03dfec3c9099481d6bba1ebe4b004c080e248353cc8bf6fb2373daacd1d57ae794758e9417de594692c36e99e6405a8dbb5a1e0f34afeca93f01a3e3386d3e57c1cae60fc62c82050b7f13e89adcb67fcfefb11093c978aa7c65e3700fa48fc825eef66d04049c7293a6b0d965ec750b8929545ddb66ede256a777feed140349da622cfed725078b839e8b84da6cc05d0fe690dbb31a6cc2ffb93969920639af4f607f1651ef254f106c6c397d46a32ffae89c45a33278f7d23f38a5964569608c2b5e91f1455a3634bd5070fb9fe3c2dd8ebfa551659b4015cb595e354a09ea475b7005d901cc4f8e540c74cd6a0f8c8adc0d7119e874ad2febb7d6575ba4d59ffbd73fbed7389cb4cf436c3d01b7036ce59994c718de0d2009f253545bfaee1c97f75f636e7ab9891778f266ab50af59e3c91ee09182fe81921a2fe9e3281213ff124b3c60a8dba5955a9e20e97902753b227b3cc62b5884fdbf1677d029b599ec0dc60ab71407973cc399359e4b3843d30ae0e5695353043aca209825f333a0c6aef6ef5d10b0aa150c26facbd23d533701f0ccbdb2ccf0832d08205a8483c6f679837008c654eae2cf9f567b93129b9db2b522d0910cbb9434d675959438b525dbeb01567df6a30a3c53ef7589b7df5240d1f83d99eeb694346880c8d8752a34e64d987b20c7eb94cdc8129603344d7d78e5c0097d88fc23aaa128f45bcdf3fb8e71dd58312573328ad99b1d81c7a9cf29e037caba7c05ee2aa5467430052da9be880e2c61be012ad82d544c3990398ef51682fdc836d8fca7a804033eaa09a14597f16cfa3786595924d7ac73759475174fa873766b26ad3944f790cc28099de6cac578ad200c2d941fcc022652c5c49766226f8b628a35aa29bdb2dfccd2213dbd2e2a524d66e73d8e3653af47d0f627d245b73b5653a4a240d9167313e5ae9fe19d63dea9fa25c42deb690c32fe2d05095a14a82e2ecc630c911f00b2b4c76e36f0c8f7f9ef5524a36ab8bb8fad83840b5c36ff35b14f78e80fc2f6fbe0dc31523393091334e55e1861007d74a40964bfb718959d7c41c6ab0e574ce26bd7d604b95a562e28fe7c78c693885a2a30f18c59209bd8e23acf31213cc5dff0ffb5d5de636443e22d69e90a37b2ea6b55cf55df079f9c0cabd4167c61d54b10d008bae9b8eda10d6f06e938f5b2d88e1709bfc255087c02cd98a6c85185a87f5f9675fcfd447c7a448a5b45b9ba81ea9931fa1a3724a5af879eda9fcd14b757bb0dc0a665cb69708967bd6a4706f55a4fc45cf298c860e67e32720c9626d86c4e369f9ddb23047048083f70a3bbbf85d362f7fc7417f015a33e0c8eae1efbdb836fdaf0673d1946c4c17305ed414d61590b54226eaa6a7db75723a4515e36e3fd660d5f2d7f8d3ddf99a72d3fa08b41197213b4f1513ed94a51d02e655f1d2334a73e657b4cf709df8dc02a0639c3bb232ce11f6e613d2645a51e91d382daafaeed9a1d1ad773397d4377f86aba9bf94c7995d54445abcd7b0587d4359da84411edcc82f68f5d6e65e2ee97db6ddb3c29b0f56dd8ac8340f34e49f715723368839e4a256570a640ef40af33bab6332cc8f7292f1d259db7cff15f26a77948f7689704aad4bdf3f568d4044937110768b7bfed29ea3512eee78ab674d65f9f3a9adff7c248f3281c0acf048259de7f52a40ef7ce5763ebbfe1acbe2a1b2b83e3965415da7146489bd63391ba66e9d2367309c73d9d9cc9b61fda7f2d6681c6a936c59aa03c9d8e6e02af9ed560a86867380067c2a3134bd3f213af3986b2a446f4c0753ada79746cda91b2534fcc592090cc56c8841020065d1e5510d8b9a3890a3795446ea6bd12253542aa752436608a248c86de64f04a5dec000d6a8e04b40ca39bf61a47dcc8367bf78caf015f95243f09050f7fe49d58dc55ce9c680ab8facabf849b0a899cc8fc1d3f91ea4a1df048153a6cbe1db44715cc007019e835014d02ad1a62c39d83456101d0b7cb5e2d71e7bed256792f37a54c6f8bfa697a8cb470cdfcb946cf640727e205c2729d1649ae9c58fbec10d53402536eb6690fe402321adb35c5d8b394ded0d02cce1e16e895b24681a55e352977a0b4ec9c13b941ca9a3334cd03425fdb23233a5639c34bfbed0ea0c21e3f91dc089f171590b9c059c882030ac01262f4d417564c3683bbb38e82930f72e2510192bdbd1f9cd0177091e41b9aec9d703e12a5a4bf486b82ce4ce2ebc6c0f74b5a7fc332d6441f4ba2e211a86c78b5bf983e4ea3aef3be3fa750da6db09cb2f3cf50a86b3b80af8f30f2961ac1144b096a3783dbb69ad9c86e09ac66021f024798561c5e8b0d86ab893516303aae4382a9316e32b29bd5418d8e6dec83ba0345869346da22cf9afdb6acb262ae66af4e5deddd4ccf03074edc10e193f6c061ed21ad394ddf01988acd93822169dd53f4eed2ffeaed6f29182b870cf79ffea759377702475b9455d21ce07c39e85c72d9c566c4326df4c3622f2497b47e226064a33c0d1c9001ad4dd3cb075d8146e9d615397c1bd63953660379bcc6a1d0d6ead2149f9a34f96a37576762cfa2edc162edcb4fb0803d14fc9e05f1c1d7882c99ac24bdb49a6e7144ce29b4d5a41c1623f4b1ec2e5f57cc196ce9c728ea602e57ead0089faee79cc5b191e8afb4c8c1d160a3c136e103c228b70917ea612598dc1fe1302898cddb2de5c46167cb309167d6417ab5777b7a5a98858ee042e14fe26049403e0eea0b3120a45628bff40251063f99b5fe549944c17694171e0909025e1fcb7c6665197015036be64a27a9255e5ff90844ac94c337d12a5992e7a5d950b49f051fc2a0aa2f4880fdbcdd31e4fe94626b6b4054d9f91fe3cc42d76bc9a85a728de59ad84bea661bb2874576b6f7afacc803b8dfe02ad88674f280ac36f1f27145cb39035b7b196ae06c37c72a206b497db441d3eb2999f3a0390b7aeefb733eb8d3af421f8d3a002608d3b3edfad8b8912d0d083878ed86e430cb7f1a5aa4a5e7908f9bfd91d2d8c5088441bf5ac4b2c23f8cda0aa277cb3bbfdcb7d81ea568ae15c7d202fca7e7bdb287ed8a01075f676c26fe91f649603851d83f323a3d30c7f086a952d4fc691bca0fafc68a5efa5123428c769334a73948a4ce22e6c225700d61dad63ce53b4e7ec1d699b4e21a1717c4476bff13b98b8ada650657b05f092ad635702ffdbf6d3bdc7c375ff69f7b859b5e297b9a61a471128b61734690041e3e3708469d99bf32ca126c7fad30f3862afeac0a2f38066eda67db55c2b4c61d60c1f88e37ee1dcccb3a99f58ab424719ac35fbb3d0249c3d871386b767e84986ac7ecca3dc5c3c9271dae16abd433b9702da79344e7472e3b8c2e6087adcb5ef5cf189ff8f1d99e18076b292fdacd40170b1d2793e6cd094b1c2b962fe8b16d9d401a1d9901626099b3bd632c057955a713ca879f7ec29ed3483618a58654c7245bd66fead6d43d2dec0f1950fc38c05d8df1a6d3695a984fd03a4138fffcc3f63ffc815525f6d9b556c7ec00f56dd52ca3d9dc22bbb153e4083de020f286ce4b669c8054014e9eba1a30ebd5741f43bf25ce1e7c49d2fa4c2290866c2335aa50f4df991083b723499925702fb4f8d99b1ae269ae6c47491a54dca03efe4035db04c85b1966402b53de35f3d7773067743c22201de52ce17bde24e73206d068ca98aad1e471577cc7c5611d487ea279a903ee04d767ccc1f36d752381c34d9d1055f5b364f013f3d4603505f85591fd362a9d6d1241be61149e3f921d8f584d5f5ab98a70901ee2f5a783e3956b26ba027ebc174ee23853b86c0327730a89c7622522f33099dfc1e0a62bbe7b747b3bf07bc341d4fcc0cadea57e98d9c8ea2ddcdf72c456c4c37ed9d64f1f89fd7e30a6a78338c04e4c6c9793712f7d31672f1893e748cc633db3be8fac516338d6e50842afb7d54eb31634dc51eddb91931bfb762d2588bdd69ac87ec74ba2ad528073252b0e6a03bb7e83f960b776a98447f07ad7ddb56a497e3025bd8f57f4cb1105807fd3ce1865512bf3bc820f9b6e64f5d5e1a29c1b83cc235767abcd947674edc6264694f5d93f5757cd5f7973283c0b39c365daaa0ebd4ba2cf5bd769728b0eefd7d6aef2712a25f457d3f4abbdd15f9c74f982ce1f718c5719a1ceab56e00e5b3583f4946b028052e18ab4d5a7d3a2ad5f8523e6c80edef9ff275e061aa18f0281ad0e0abf6cb3aeac55fe1add5e4fc46dad569218c3343343a36efe411c2d0e438015bd2464cf8207e5b824e30b99fb6abe503dde165b04894e7d210c6577e1eadc137dc26b1ec4459e389d8c6af72645c3e8e4f32e0a60de7c959090793138528c4018698173d2ff27a9ce434b3355b160d55baa01879a64fb3b11873af76cef9c42b0c51c3f60b3b03d421471c3ddc62b4b73fe30b1187db14318267d8dbace80809e1c1cc1ef2c706719c5a508d3084710a18e4367cd8547a39e014c2ced165de22940e150431c9b9476ff4efae6cd0b6659bd505cd3b0708e74286424436593403cbbf84d1b0b0770ed26df9da8ed3f1a93c9a912f0069fb6a179f8ae01e622bb522b5eb19aa33bd26829a267be9ec641e096f0ec1704e7b3d8a90cf8bb2184f694ebbc8816665c0bfc2df6bcc332d2c8b92bb985c3532ea9322af4bbfcf13926fdf68ca49e2387385b56b87797be0b88004d9dabd19b61b19e93406dea697184a6e1bd67fd5d752c1f6f0fbea2876008d854548b5689c4c2ec18059150986cb599b49b4fb1a6e86d3a7f0efe25b61d7771fc2f67724222f713bf4b5b25e2c66f153243d29d8ef37a4723d53d8da2a503e1a421cbbaef9a80cdcd8850c27b420de2c32dd1608346d75bf5dcd1748ce56fbff8f2f12f8a6adc9a2553d4ad877b47c629c7762097195e30af24964a018f9c8c72153e8b052b786e03b46a8245b90e2a2c37f7351905f1008074c165d88997ad781511ff75831154b0a2008b963a5f9ef0be5e1c6f7a91f45ff746ba22a8b694d7b03578afc79177d6330f3bda9f39f01ea7792874edc40734a382e013c4aa60b877380c21e024ada1033a25fc12f06dfd3f5b47f6949ef7ce2bdb8568c02b2d7d8fc79b1e39540199f89310d9756403362e6e11aa396591ce402b2dfaf1132978b5157f25f5ae607910ba9abeb08040d34dea0788dec6c834ad1b0be3d0a90cdbdc8114f021187238614b4f9e33048604e267deadb0b18189da5622b1226d44fe777c6c27f33a8dc0fb64fefa7395f3d6463694c134f772fb589c897a46a9288ddd3aec08591f02fc533f5ce164befb584ba9a9eb89e18c5a5493fcfc86371e9005e8610e35b168744c1a8a298af49c502b019026e54feac495e915f0c4e06adbd54add8a1192df86aa8c43a495bc3f4c95ad098ec6418eb1f3fc44f93c96630602ee842959306773fc3af6eb1ab37a4604aee358f855d0314a0e401bc079e9b5de38d43fab5699d0d92c8c69293fd6df59f8147adcd1d92aa4ad3085a3429d8f64215b7151165d50070f321abdd26b7070601a857af0ab57c0c8a24a78c64aff34f95320320ab2db95e41a569cb743133524ccc22922c377537a6d0b42ceccd5fd5d8b7a0ec2651bc4cdb43b3306465e4e314f1daf914cda866436c42e38ac2fb315a630d50b5a6ba9a1b4ba3dafb331e72b8a558658efbb21db6e6fab77db2fde05ab857591600befca71814c9184f193af839ad2e0ed7f28cf652b6c8fd68f349c28bc15b8f5c90fd76b4540238457cbf7118103f21689d87eb506a00eb95f04c4b2313d5e7dc85bd980f01061c6109f7f8d5ae74cec2aed4dd0d952f82197008885b649c8e39ac5e1d51f74cc7a00cb6207412e8cf8c7f3e31f91f8f8b6c5acc52e6a913c7f41e9f8e915ed8663dc73349d09ccebd75465eafcd5abb2f5cf7be72136a5a2243c912522ed72c62c8bb88783abe7b7413c4caa1eb8560336e751dae3ec200239731cc15e2b1baf232e98cbe3d2af23a66949f2cf9fc969a69fe1518e85c875a4cf394ec5cb902a9b240575c04324437154cc5aa540c3c769aa571a2a82085bee4332988fba82f1e283d36f91f47dea50a603afb4a622b2f33398d120ad0d4f831fb63ad881940b16e933a88a0b269a76148218f857117309928d50eef1125f71bff114c8b6d2c67929f537cf027fef95ba72ac2b42a7e65d4689d944393b4e9849006c9ca89f38513508d3d57b5bde82e374a3fb8b67800beb1affca47246ba591c6d38c2d9456c5e51734fabb943a0b63254bdb3ca30776f0b832ff68ce41eb08e442e4db9a9377aa69be75aa886243b8baa25bf0f391e5e487a0876358bbdc2c0c4e4e58fb06c59ce8acf677acc8bb96635322e8c99e17e6be1523c74a62720177e467016649897f2d820bca9c3cfb2e5ab6e9040b4fc239c6e84a622a83d2153d2f71cb4e152cb0d2cb1874db1c08a5fada290d665508b55f5e0421714661d8933aac1c6bd151acb5d527aa93d27b9c5e1ff21436a4a5e7620b3767badd11fc0b8384acbbed96fa3f9bbe56f38568a03948a64766d8b037fa637d0889584ab8b4e538a55f2c11272336b6662394214c5fd04bec5d7793c0c994e25ca8939ae62187cc87e99ae07427f97e7ce4e463f2acab6b71b9109457db0b3694a6c9c8fad770e9d23ce008de454ab6ac610cd93b10ab0a76d56e3d6c374975c1932b7dbecee671253bdb09ecda374ca96f33453770d1d0a8f35a0a9fb0dd052dd6b2f369a46a3cb0f9ae775f14ecc2cdbb973bbde82e29d1bd2248cc41c4f26b13ef13ed3a213516a01","isRememberEnabled":false,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"b94afc8a28162dbac1f0768784f694cc"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
